# Ajuster le modèle MA(2) avec arima() sur les 200 premières observations
model <- arima(X_train, order = c(0, 0, 2))  # MA(2) -> p=0, d=0, q=2
# Afficher les résultats de l'estimation
summary(model)
# Nombre total d'observations
n <- 300
# Paramètres du modèle MA(2)
m <- 3
theta1 <- 1/2
theta2 <- -1/3
# Génération des bruits blancs epsilon_t
epsilon <- rnorm(n + 2)  # Nous générons n + 2 valeurs pour gérer les indices négatifs
# Initialisation du vecteur de la série X
X <- numeric(n)
# Simulation du processus MA(2)
for (t in 3:n) {
X[t] <- m + epsilon[t] + theta1 * epsilon[t-1] + theta2 * epsilon[t-2]
}
# Sélection des 200 premières observations pour l'estimation
X_train <- X[1:200]
# Ajuster le modèle MA(2) avec arima() sur les 200 premières observations
model <- arima(X_train, order = c(0, 0, 2))  # MA(2) -> p=0, d=0, q=2
# Afficher les résultats de l'estimation
summary(model)
# Paramètres du modèle MA(2)
m <- 3
theta1 <- 1/2
theta2 <- -1/3
T <- 300  # Nombre de points dans la trajectoire
# Générer les bruits Z_t (normal standard)
Z <- rnorm(T + 2)  # On génère T+2 valeurs pour couvrir Z_t, Z_{t-1}, Z_{t-2}
# Initialisation du vecteur pour stocker les valeurs X_t
X <- numeric(T)
# Calcul de X_t pour t = 1, 2, ..., 300
for (t in 3:T) {
X[t] <- m + theta1 * Z[t-1] + theta2 * Z[t-2]
}
# Tracer la trajectoire
plot(1:T, X, type = "l", col = "blue", main = "Trajectoire du processus MA(2)",
xlab = "Temps (t)", ylab = "X_t")
# Utiliser les 200 premières observations pour l'estimation
X_train <- X[1:200]
# Estimer les paramètres du modèle MA(2) à partir des 200 premières observations
fit <- arima(X_train, order = c(0, 0, 2))
# Afficher les résultats de l'estimation
summary(fit)
# Utiliser les 200 premières observations pour l'estimation
X_train <- X[1:200]
# Estimer les paramètres du modèle MA(2) à partir des 200 premières observations
fit <- arima(X_train, order = c(0, 0, 2))
# Afficher les résultats de l'estimation
summary(fit)
# Prédire les valeurs futures pour t = 200, 201, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred
X_pred_lower <- predictions$lower
X_pred_upper <- predictions$upper
# Vraies valeurs observées pour t = 200, ..., 300
X_true <- X[201:T]
# Tracer les valeurs observées et les valeurs prédites
plot(201:T, X_true, type = "l", col = "blue", lwd = 2,
xlab = "Temps (t)", ylab = "X_t", main = "Comparaison des valeurs observées et prédites")
lines(201:T, X_pred, col = "red", lwd = 2)
lines(201:T, X_pred_lower, col = "green", lty = 2)
lines(201:T, X_pred_upper, col = "green", lty = 2)
# Ajouter une légende
legend("topleft", legend = c("Valeurs observées", "Prédictions", "Intervalle de confiance"),
col = c("blue", "red", "green"), lty = c(1, 1, 2), lwd = 2)
# Prédire les valeurs futures pour t = 200, 201, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred
X_pred_lower <- predictions$lower
X_pred_upper <- predictions$upper
# Vraies valeurs observées pour t = 200, ..., 300
X_true <- X[201:T]
# Créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Prédire les valeurs futures pour t = 200, 201, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred
X_pred_lower <- predictions$lower
X_pred_upper <- predictions$upper
# Vraies valeurs observées pour t = 200, ..., 300
X_true <- X[201:T]
# Créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Utiliser les 200 premières observations pour l'estimation
X_train <- X[1:200]
# Estimer les paramètres du modèle MA(2) à partir des 200 premières observations
fit <- arima(X_train, order = c(0, 0, 2))
# Afficher les résultats de l'estimation
summary(fit)
# Prédire les valeurs futures pour t = 200, 201, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred
X_pred_lower <- predictions$lower
X_pred_upper <- predictions$upper
# Vraies valeurs observées pour t = 200, ..., 300
X_true <- X[201:T]
# Créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Prédire les valeurs futures pour t = 200, 201, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred
X_pred_lower <- predictions$lower[,2]  # Intervale inférieur à 95%
X_pred_upper <- predictions$upper[,2]  # Intervalle supérieur à 95%
# Vraies valeurs observées pour t = 200, ..., 300
X_true <- X[201:T]
# Créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Paramètres du modèle MA(2)
m <- 3
theta1 <- 1/2
theta2 <- -1/3
T <- 300  # Nombre total d'observations
# Générer les bruits Z_t (normal standard)
Z <- rnorm(T + 2)  # On génère T+2 valeurs pour couvrir Z_t, Z_{t-1}, Z_{t-2}
# Initialisation du vecteur pour stocker les valeurs X_t
X <- numeric(T)
# Calcul de X_t pour t = 1, 2, ..., 300
for (t in 3:T) {
X[t] <- m + theta1 * Z[t-1] + theta2 * Z[t-2]
}
# Utiliser les 200 premières observations pour l'estimation
X_train <- X[1:200]
# Estimer les paramètres du modèle MA(2) à partir des 200 premières observations
fit <- arima(X_train, order = c(0, 0, 2))
# Prédire les valeurs futures pour t = 200, 201, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred
X_pred_lower <- predictions$lower[,2]  # Intervale inférieur à 95%
X_pred_upper <- predictions$upper[,2]  # Intervalle supérieur à 95%
# Vraies valeurs observées pour t = 200, ..., 300
X_true <- X[201:T]
# Créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Prédire les valeurs futures pour t = 201, 202, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred  # Valeurs prédites
X_pred_lower <- predictions$lower[,2]  # Intervalle inférieur à 95%
X_pred_upper <- predictions$upper[,2]  # Intervalle supérieur à 95%
# Vraies valeurs observées pour t = 201, ..., 300
X_true <- X[201:T]
# Créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Prédire les valeurs futures pour t = 201, 202, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Vérification de la structure des prédictions
str(predictions)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred  # Valeurs prédites
X_pred_lower <- predictions$lower[,2]  # Intervalle inférieur à 95%
X_pred_upper <- predictions$upper[,2]  # Intervalle supérieur à 95%
# Vérifier que les longueurs sont correctes
cat("Longueur des prévisions: ", length(X_pred), "\n")
cat("Longueur des intervalles inférieurs: ", length(X_pred_lower), "\n")
cat("Longueur des intervalles supérieurs: ", length(X_pred_upper), "\n")
# Vraies valeurs observées pour t = 201, ..., 300
X_true <- X[201:T]
# Vérifier que toutes les longueurs sont cohérentes
cat("Longueur des vraies valeurs: ", length(X_true), "\n")
# Si toutes les longueurs sont correctes, créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Prédire les valeurs futures pour t = 201, 202, ..., 300
# Spécifier interval = "confidence" pour obtenir les intervalles de confiance
predictions <- predict(fit, n.ahead = T - 200, interval = "confidence")
# Vérification de la structure des prédictions
str(predictions)
# Extraire les valeurs prédites et les intervalles de confiance
X_pred <- predictions$pred  # Valeurs prédites
X_pred_lower <- predictions$lower[,2]  # Intervalle inférieur à 95%
X_pred_upper <- predictions$upper[,2]  # Intervalle supérieur à 95%
# Vérifier que les longueurs sont correctes
cat("Longueur des prévisions: ", length(X_pred), "\n")
cat("Longueur des intervalles inférieurs: ", length(X_pred_lower), "\n")
cat("Longueur des intervalles supérieurs: ", length(X_pred_upper), "\n")
# Vraies valeurs observées pour t = 201, ..., 300
X_true <- X[201:T]
# Vérifier que toutes les longueurs sont cohérentes
cat("Longueur des vraies valeurs: ", length(X_true), "\n")
# Si toutes les longueurs sont correctes, créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Prédire les valeurs futures pour t = 201, 202, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les erreurs standard
X_pred <- predictions$pred  # Valeurs prédites
se <- predictions$se        # Erreurs standard des prévisions
# Calculer les intervalles de confiance à 95%
z_value <- 1.96  # Valeur pour un intervalle de confiance à 95%
X_pred_lower <- X_pred - z_value * se  # Borne inférieure
X_pred_upper <- X_pred + z_value * se  # Borne supérieure
# Vérification des longueurs
cat("Longueur des prévisions: ", length(X_pred), "\n")
cat("Longueur des intervalles inférieurs: ", length(X_pred_lower), "\n")
cat("Longueur des intervalles supérieurs: ", length(X_pred_upper), "\n")
# Vraies valeurs observées pour t = 201, ..., 300
X_true <- X[201:T]
# Vérification que toutes les longueurs sont cohérentes
cat("Longueur des vraies valeurs: ", length(X_true), "\n")
# Si toutes les longueurs sont correctes, créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Tracer les valeurs observées et les valeurs prédites avec ggplot2
ggplot(df, aes(x = t)) +
# Tracer les valeurs observées (en bleu)
geom_line(aes(y = X_true), color = "blue", size = 1.2) +
# Tracer les valeurs prédites (en rouge)
geom_line(aes(y = X_pred), color = "red", size = 1.2) +
# Tracer les intervalles de confiance (en vert)
geom_ribbon(aes(ymin = X_pred_lower, ymax = X_pred_upper), fill = "green", alpha = 0.3) +
# Ajouter des labels et un titre
labs(title = "Comparaison des valeurs observées et prédites",
x = "Temps (t)",
y = "X_t") +
theme_minimal() +
theme(legend.position = "none")
# Prédire les valeurs futures pour t = 201, 202, ..., 300
predictions <- predict(fit, n.ahead = T - 200)
# Extraire les valeurs prédites et les erreurs standard
X_pred <- predictions$pred  # Valeurs prédites
se <- predictions$se        # Erreurs standard des prévisions
# Calculer les intervalles de confiance à 95%
z_value <- 1.96  # Valeur pour un intervalle de confiance à 95%
X_pred_lower <- X_pred - z_value * se  # Borne inférieure
X_pred_upper <- X_pred + z_value * se  # Borne supérieure
# Vraies valeurs observées pour t = 201, ..., 300
X_true <- X[201:T]
# Si toutes les longueurs sont correctes, créer un data frame pour ggplot
df <- data.frame(
t = 201:T,
X_true = X_true,
X_pred = X_pred,
X_pred_lower = X_pred_lower,
X_pred_upper = X_pred_upper
)
# Tracer les valeurs observées et les valeurs prédites avec ggplot2
ggplot(df, aes(x = t)) +
# Tracer les valeurs observées (en bleu)
geom_line(aes(y = X_true), color = "blue", size = 1.2) +
# Tracer les valeurs prédites (en rouge)
geom_line(aes(y = X_pred), color = "red", size = 1.2) +
# Tracer les intervalles de confiance (en vert)
geom_ribbon(aes(ymin = X_pred_lower, ymax = X_pred_upper), fill = "green", alpha = 0.3) +
# Ajouter des labels et un titre
labs(title = "Comparaison des valeurs observées et prédites",
x = "Temps (t)",
y = "X_t") +
theme_minimal() +
theme(legend.position = "none")
rm(list=ls())
try(dev.off(),silent = T)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(survival)
##########DGP parameters
n <- 500        #sample size
l.Y <- 1      #parameter of the distribution of of Y
l.C <- 1      #parameter of the distribution of of C
tau <- 0.1      #quantile
Y <- rexp(n = n, rate = l.Y)
C <- rexp(n = n, rate = l.C)
plot(Y)
plot(C)
hist(C)
hist(C)
hist(Y)
hist(C)
##########Data
T_obs <- pmin(Y, C)
delta_obs <- (Y <= C) * 1
print(c('cesoring proportion ', 1-mean(delta_obs)))
delta_obs <- (Y <= C)
delta_obs <- (Y <= C) * 1
delta_obs <- (Y <= C)
* 1
delta_obs <- (Y <= C) * 1
source("~/Downloads/lecture_codes_Oct10.R", echo=TRUE)
library(dplyr)
library(GGally) # pour le graphique de la question 1
library(car)
library(leaps)
rm(list=ls())
try(dev.off(),silent = T)
readLines("ozone.txt")[1:5]
bdd <- read.table("ozone.txt")
bdd <- read.table("ozone.txt")
str(bdd)
c(NA, head(bdd$maxO3, -1))
View(bdd)
bdd$maxO3v <- c(NA, head(bdd$maxO3, -1))
bdd %>%
mutate(maxO3v = c(NA, head(bdd$maxO3, -1)), .after = maxO3)
bdd <- read.table("ozone.txt")
str(bdd)
bdd <- bdd %>%
mutate(maxO3v = c(NA, head(bdd$maxO3, -1)), .after = maxO3)
View(bdd)
reg <- lm(maxO3~T12+Ne9+Vx9+maxO3v)
reg <- lm(maxO3~T12+Ne9+Vx9+maxO3v, data=bdd)
reg <- lm(maxO3~T12+Ne9+Vx9+maxO3v, data=bdd)
summary(lm)
reg <- lm(maxO3~T12+Ne9+Vx9+maxO3v, data=bdd)
summary(reg)
boxplot(maxO3~pluie)
boxplot(maxO3~pluie, data = bdd)
modele_enrichi <- lm(maxO3 ~ T12 * pluie + Ne9 * pluie + Vx9 * pluie + maxO3v * pluie, data = data)
modele_enrichi <- lm(maxO3 ~ T12 * pluie + Ne9 * pluie + Vx9 * pluie + maxO3v * pluie, data = bdd)
modele_enrichi <- lm(maxO3 ~ T12 * pluie + Ne9 * pluie + Vx9 * pluie + maxO3v * pluie, data = bdd)
str(modele_enrichi)
modele_enrichi <- lm(maxO3 ~ T12 * pluie + Ne9 * pluie + Vx9 * pluie + maxO3v * pluie, data = bdd)
summmary(modele_enrichi)
modele_enrichi <- lm(maxO3 ~ T12 * pluie + Ne9 * pluie + Vx9 * pluie + maxO3v * pluie, data = bdd)
summmary(modele_enrichi)
bartlett.test(maxO3~pluie)
bartlett.test(maxO3~pluie, data = bdd)
bartlett.test(maxO3~pluie, data = bdd)
leveneTest(maxO3~pluie, data = bdd)
leveneTest(maxO3~pluie, data = bdd)
bartlett.test(maxO3~pluie, data = bdd)
leveneTest(maxO3~pluie, data = bdd)
bartlett.test(maxO3~pluie, data = bdd)
leveneTest(maxO3~pluie, data = bdd)
anova(lm(maxO3~pluie))
bartlett.test(maxO3~pluie, data = bdd)
leveneTest(maxO3~pluie, data = bdd)
anova(lm(maxO3~pluie, data = bdd))
modele_enrichi <- lm(maxO3 ~ T12+Ne9+Vx9+maxo3v)*pluie, data=bdd
modele_enrichi <- lm(maxO3 ~ (T12+Ne9+Vx9+maxo3v)*pluie, data=bdd)
modele_enrichi <- lm(maxO3 ~ (T12+Ne9+Vx9+maxO3v)*pluie, data=bdd)
modele_enrichi <- lm(maxO3 ~ (T12+Ne9+Vx9+maxO3v)*pluie, data=bdd)
summary(modele_enrichi)
library(dplyr)
library(GGally) # pour le graphique de la question 1
library(car)
library(leaps)
rm(list=ls())
try(dev.off(),silent = T)
readLines("chdage.txt")[1:5]
bdd <- read.table("chdage.txt")
str(bdd)
View(bdd)
bdd$ched <- as.factor(bdd$ched)
bdd$chd <- as.factor(bdd$chd)
bdd$agegrp <- as.factor(bdd$agegrp)
bdd$chd <- as.factor(bdd$chd)
bdd$agegrp <- as.factor(bdd$agegrp)
str(bdd)
boxplot(age~chd, data=bdd)
# Chargement des bibliothèques nécessaires
library(ggplot2)
# Données
quantiles <- c(0.05, 0.1, 0.2, 0.3, 0.35, 0.4, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95)
values <- c(3.005, 4.335, 5.625, 6.370, 6.675, 7.380, 8.325, 8.750, 9.295, 9.800, 10.200, 11.005, 11.450, 11.995, 12.700, 13.005)
# Création du data frame
data <- data.frame(Quantiles = quantiles, Values = values)
# Graphique en bâtons
ggplot(data, aes(x = Quantiles, y = Values)) +
geom_bar(stat = "identity", fill = "skyblue", color = "black", width = 0.03) +
labs(title = "Graphique en bâtons des quantiles",
x = "Quantiles",
y = "Valeurs") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Chargement des bibliothèques nécessaires
library(ggplot2)
# Données
values <- c(3.005, 4.335, 5.625, 6.370, 6.675, 7.380, 8.325, 8.750, 9.295,
9.800, 10.200, 11.005, 11.450, 11.995, 12.700, 13.005)
# Création du data frame
data <- data.frame(Notes = values)
# Histogramme avec courbe de densité
ggplot(data, aes(x = Notes)) +
geom_histogram(aes(y = ..density..), bins = 10, fill = "skyblue", color = "black", alpha = 0.7) +
geom_density(color = "red", size = 1) +
labs(title = "Distribution des notes à l'examen",
x = "Notes",
y = "Densité") +
theme_minimal()
# Les quantiles donnés
quantiles <- c(3.005, 4.335, 5.625, 6.370, 6.675, 7.380, 8.325, 8.750, 9.295,
9.800, 10.200, 11.005, 11.450, 11.995, 12.700, 13.005, 13.505,
14.460, 16.250)
max_value <- 20
# Noms des quantiles
quantile_names <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5,
0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95)
# Boîte à moustaches
boxplot(quantiles,
main = "Distribution des quantiles des résultats d'examen",
ylab = "Résultats",
col = "lightblue",
ylim = c(0, max_value))
# Ajouter un graphique de quantiles
plot(quantile_names, quantiles, type = "o",
main = "Quantiles des résultats d'examen",
xlab = "Quantiles",
ylab = "Résultats",
col = "darkblue",
pch = 19,
ylim = c(0, max_value))
grid()
library(ggplot2)
# Les quantiles donnés
quantiles <- c(3.005, 4.335, 5.625, 6.370, 6.675, 7.380, 8.325, 8.750, 9.295,
9.800, 10.200, 11.005, 11.450, 11.995, 12.700, 13.005, 13.505,
14.460, 16.250)
max_value <- 20
# Noms des quantiles
quantile_names <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5,
0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95)
# Créer un data frame pour ggplot
data <- data.frame(
Quantiles = quantile_names,
Resultats = quantiles
)
# Graphique en bâtons
ggplot(data, aes(x = as.factor(Quantiles), y = Resultats)) +
geom_bar(stat = "identity", fill = "skyblue", color = "darkblue") +
labs(
title = "Quantiles des résultats d'examen",
x = "Quantiles",
y = "Résultats"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5)
) +
scale_y_continuous(limits = c(0, 20), breaks = seq(0, 20, by = 2)) +
geom_hline(yintercept = max_value, color = "red", linetype = "dashed", size = 0.8) +
annotate("text", x = length(quantile_names), y = max_value, label = "Max = 20",
vjust = -0.5, color = "red")
density_resultats <- density(data$Resultats, adjust = 1.5)
# Créer un graphique pour la densité
ggplot(data = data.frame(x = density_resultats$x, y = density_resultats$y), aes(x, y)) +
geom_line(color = "blue", size = 1) +
geom_area(fill = "skyblue", alpha = 0.5) +
labs(
title = "Estimation de la densité des résultats d'examen",
x = "Résultats",
y = "Densité"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5)
) +
geom_vline(xintercept = quantiles, color = "red", linetype = "dotted") +
annotate("text", x = 20, y = max(density_resultats$y), label = "Max = 20",
vjust = -0.5, color = "red")
setwd("~/Documents/statagora")
